---
title: "regression_analysis_SMA"
author: "Josh Nitschke"
date: "2023-08-31"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# install.packages("remotes")
remotes::install_github("traitecoevo/smatr")

library(tidyverse)
library(here)
library(smatr)
library(janitor)
library(skimr)
library(gridExtra)
library(olsrr)
library(purrr)
library(tidyr)
```

## read in processed data
```{r}
biomass_frozen_outliers_identified <- read_csv(here("data/processed/biomass_frozen_outliers_identified.csv"))
```

## running SMA's on untransformed data
```{r}
taxa_nested_sma <- biomass_frozen_outliers_identified |> 
  group_nest(taxa_clean) |>
  mutate(sma_object = map(.x = data,
                          ~ sma(dm_g ~ wm_g, data = .x)))

```

### Check assumptions

#### homogeneity of variance
```{r}
taxa_nested_sma_fitted_resid <- taxa_nested_sma |> 
  mutate(fitted_resid = map(.x = sma_object,
                             .f = ~ tibble(fitted = fitted(.x), residuals = residuals(.x))),
         fitted_resid_plot = map2(.x = fitted_resid,
                     .y = taxa_clean,
                     .f = ~ ggplot(data = .x, aes(x = fitted, y = residuals)) + 
                       ggtitle(.y) +
                       labs(x = "fitted value", y = "residual") +
                       geom_point() + 
                       geom_hline(yintercept = 0) +
                       theme_bw() + 
                       theme(panel.border = element_blank(), panel.grid.major = element_blank(), 
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), 
                       axis.text = element_text(size = 12, colour = "black"), axis.title = element_text(size = 14))))
taxa_nested_sma_fitted_resid$fitted_resid_plot

```

#### Normality
```{r}
taxa_nested_sma_fitted_resid_qq <- taxa_nested_sma_fitted_resid |>
  mutate(qq = map2(.x = sma_object,
                  .y = taxa_clean,
                  .f = ~ plot(.x, which = "qq", main = paste("qq-plot:",.y))))
```
# Excluding outliers
## running SMA's on untransformed data
```{r}
taxa_nested_sma_outliers_removed <- biomass_frozen_outliers_identified |> 
  filter(keep_data == TRUE) |>
  group_nest(taxa_clean) |>
  mutate(sma_object = map(.x = data,
                          ~ sma(dm_g ~ wm_g, data = .x)))

```

### Check assumptions

#### homogeneity of variance
```{r}
taxa_nested_sma_outliers_removed_fitted_resid <- taxa_nested_sma_outliers_removed |> 
  mutate(fitted_resid = map(.x = sma_object,
                             .f = ~ tibble(fitted = fitted(.x), residuals = residuals(.x))),
         fitted_resid_plot = map2(.x = fitted_resid,
                     .y = taxa_clean,
                     .f = ~ ggplot(data = .x, aes(x = fitted, y = residuals)) + 
                       ggtitle(.y) +
                       labs(x = "fitted value", y = "residual") +
                       geom_point() + 
                       geom_hline(yintercept = 0) +
                       theme_bw() + 
                       theme(panel.border = element_blank(), panel.grid.major = element_blank(), 
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), 
                       axis.text = element_text(size = 12, colour = "black"), axis.title = element_text(size = 14))))
taxa_nested_sma_outliers_removed_fitted_resid$fitted_resid_plot

```
Alternative method
```{r}
taxa_nested_sma_outliers_removed_fitted_resid2 <- taxa_nested_sma_outliers_removed |>
  mutate(scat = map2(.x = sma_object,
                  .y = taxa_clean,
                  .f = ~ plot(.x, which = "residual", main = .y)))
```

#### Normality
```{r}
taxa_nested_sma_outliers_removed_fitted_resid_qq <- taxa_nested_sma_outliers_removed_fitted_resid |>
  mutate(qq = map2(.x = sma_object,
                  .y = taxa_clean,
                  .f = ~ plot(.x, which = "qq", main = paste("qq-plot:",.y))))
```


## Running SMA's on log10-transformed data and plotting
```{r}
taxa_nested_sma_log10_plot <- biomass_frozen_outliers_identified |> 
  group_nest(taxa_clean) |>
  mutate(sma_log10_object = map(.x = data,
                          ~ sma(dm_g ~ wm_g, log = "xy", data = .x)),
         sma_log10_plots = map2(.x = sma_log10_object,
                         .y = taxa_clean,
                         .f = ~ plot(.x, xlab = "wet mass (g)", ylab = "dry mass (g)", main = .y)))
         
taxa_nested_sma_log10_plot$sma_log10_object
```

## check assumptions again

#### homogeneity of variance
```{r}
taxa_nested_sma_log10_plot_fitted_resid <- taxa_nested_sma_log10_plot |> 
  mutate(fitted_resid = map(.x = sma_log10_object,
                             .f = ~ tibble(fitted = fitted(.x), residuals = residuals(.x))),
         fitted_resid_plot = map2(.x = fitted_resid,
                     .y = taxa_clean,
                     .f = ~ ggplot(data = .x, aes(x = fitted, y = residuals)) + 
                       ggtitle(.y) +
                       labs(x = "fitted value", y = "residual") +
                       geom_point() + 
                       geom_hline(yintercept = 0) +
                       theme_bw() + 
                       theme(panel.border = element_blank(), panel.grid.major = element_blank(), 
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), 
                       axis.text = element_text(size = 12, colour = "black"), axis.title = element_text(size = 14))))
taxa_nested_sma_log10_plot_fitted_resid$fitted_resid_plot

```

#### Normality
```{r}
taxa_nested_sma_log10_plot_fitted_resid_qq <- taxa_nested_sma_log10_plot_fitted_resid |>
  mutate(qq = map2(.x = sma_log10_object,
                  .y = taxa_clean,
                  .f = ~ plot(.x, which = "qq", main = paste("qq-plot:",.y))))
```


### Pull out regression equation for back transformation

```{r}
# Get coefficients from SMA

taxa_nested_sma_log10_plot_coef <- taxa_nested_sma_log10_plot |>
  mutate(coef = map(.x = sma_log10_object,
                    .f = ~smatr:::coef.sma(.x)),
         conf_int = map(.x = sma_log10_object,
                             .f = ~confint(.x, level = 0.95)),
         summary = map(.x = sma_log10_object,
                       .f = ~ (smatr:::summary.sma(.x))))
str(taxa_nested_sma_log10_plot_coef$sma_log10_object[1])

long_summary <- taxa_nested_sma_log10_plot_coef |> 
  select(taxa_clean, summary) |> 
  unnest(summary) |> 
  select(taxa_clean, n, r2, pval, Slope, Slope_lowCI, Slope_highCI, Int, Int_lowCI, Int_highCI)

# Alternative method
##### Fonti's try
# Goal is to get a df with taxa clean, coeffs and CI as columns
long_coefs <- taxa_nested_sma_log10_plot_coef |> 
  select(taxa_clean, coef, conf_int) |> 
  unnest(c(coef, conf_int)) |>  # Not what we want
  mutate(coef_type = rep(c("elevation", "slope"), length(taxa_nested_sma_log10_plot_coef$taxa_clean))) |> 
  select(taxa_clean, coef_type, coef, Lower, Upper) |> 
  clean_names()

# Pivot wider multiple columns
long_coefs |> 
  pivot_wider(names_from = coef_type, values_from = c(coef, lower, upper)) |> 
  select(taxa_clean, 
         ends_with("elevation"), 
         ends_with("slope")) 

# back-transforming intercept and confidence intervals to get parameter 'a' in power equation: y = ax^b
long_summary_a <- long_summary |> 
  mutate(a = 10^Int,
         a_low_ci = 10^Int_lowCI,
         a_high_ci = 10^Int_highCI)


# manual calculation of SE's of coefs
#SE of slope: sqrt [ Σ(yi – ŷi)2 / (n – 2) ] / sqrt [ Σ(xi – x)2 ].
biomass_frozen_outliers_identified_amp <- biomass_frozen_outliers_identified |>
  filter(taxa_clean == "Amphipoda")

sqrt((sum(biomass_frozen_outliers_identified_amp$dm_g-mean(biomass_frozen_outliers_identified_amp$dm_g))^2)/(length(biomass_frozen_outliers_identified_amp$dm_g)-2))/sqrt(sum(biomass_frozen_outliers_identified_amp$wm_g-mean(biomass_frozen_outliers_identified_amp$wm_g))^2)



---
coefs <- data.frame(taxon = taxa_nested_sma_log10_plot_coef$taxa_clean, 
                    coef_value = list_c(taxa_nested_sma_log10_plot_coef$coef), 
                    coefficient = names(list_c(taxa_nested_sma_log10_plot_coef$coef)),
                    conf_int_value = list_c(taxa_nested_sma_log10_plot_coef$conf_int)) |> 
  pivot_wider(names_from = "coefficient", values_from = "coef_value")|>
  data.frame(elevation = c(coefs$elevation), slope = c(coefs$slope))

coefs

#####

long_coefs <- data.frame(taxon = taxa_nested_sma_log10_plot_coef$taxa_clean, 
                    coef_value = list_c(taxa_nested_sma_log10_plot_coef$coef), 
                    coefficient = names(list_c(taxa_nested_sma_log10_plot_coef$coef)),
                    conf_int_value = list_c(taxa_nested_sma_log10_plot_coef$conf_int)) 

row.names(long_coefs) <- NULL

long_coefs |> 
  pivot_wider(values_from = c(coef_value, conf_int_value.Lower, conf_int_value.Upper))
---




intercept <- smatr:::coef.sma(log10_dry_wet_sma)[1] # Take the first value
intercept

slope <- smatr:::coef.sma(log10_dry_wet_sma)[2] # Take the second value
slope

# log10(DM) = slope * log10(WM) + intercept
# Exponentiate log10 using 10^
# DM = WM^slope * 10^intercept
# Create a new variable BT = Back transformed 
data_BF <- data |> 
  mutate(BT_DM = (wm_g^slope) * (10^intercept))  

# Plot back transformed data
# Histograms
hist(data_BF$dm_g) # Raw data
hist(data_BF$BT_DM) # Back transformed

# Scatterplots
# Raw data
ggplot(data_BF, aes(x = dm_g, y= wm_g)) +
  geom_point(alpha = 0.50) 

# Back transformed
ggplot(data_BF, aes(x = BT_DM, y= wm_g)) +
  geom_point(alpha = 0.50)
```

### calculating ratios and associated summary statistics

```{r}

biomass_frozen_outliers_identified_ratios <- biomass_frozen_outliers_identified |>
  mutate(dm_wm = dm_g/wm_g)
  
biomass_frozen_outliers_identified_ratios |>
  group_by(taxa_clean) |>
  summarise(n = n(),
            mean_dm_wm = mean(dm_wm),
            sd_dm_wm = sd(dm_wm),
            lower_ci_mean_dm_wm = mean_dm_wm-0.95*(sd_dm_wm/sqrt(n)),
            upper_ci_mean_dm_wm = mean_dm_wm+0.95*(sd_dm_wm/sqrt(n)),
            geom_mean = prod(dm_wm)^(1/n),
            min_dm_wm = min(dm_wm),
            median_dm_wm = median(dm_wm),
            max_dm_wm = max(dm_wm))

```