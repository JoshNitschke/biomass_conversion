---
title: "SMA regression analysis"
author: "Josh Nitschke"
date: "2023-08-31"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# install.packages("remotes")
remotes::install_github("traitecoevo/smatr")

library(tidyverse)
library(here)
library(smatr)
library(janitor)
library(skimr)
library(gridExtra)
library(olsrr)
library(purrr)
library(tidyr)


# install.packages(c("nlrwr", "boot"))
# remotes::install_github("cran/nlrwr")
# library(nlrwr)
# library(boot)
```

## Reading in cleaned data

```{r}
biomass_frozen_outliers_identified <- read_csv(here("data/processed/biomass_frozen_outliers_identified.csv"))
```

## Running SMA's on untransformed data

```{r}
taxa_nested_sma <- biomass_frozen_outliers_identified |> 
  group_nest(taxa_clean) |>
  mutate(sma_object = map(.x = data,
                          ~ sma(dm_g ~ wm_g, data = .x)))
```

### Checking assumptions

#### Homogeneity of variance

```{r}
taxa_nested_sma_fitted_resid <- taxa_nested_sma |> 
  mutate(fitted_resid = map(.x = sma_object,
                             .f = ~ tibble(fitted = fitted(.x), residuals = residuals(.x))),
         fitted_resid_plot = map2(.x = fitted_resid,
                     .y = taxa_clean,
                     .f = ~ ggplot(data = .x, aes(x = fitted, y = residuals)) + 
                       ggtitle(.y) +
                       labs(x = "fitted value", y = "residual") +
                       geom_point() + 
                       geom_hline(yintercept = 0, linetype = 2) +
                       theme_bw() + 
                       theme(panel.border = element_blank(), panel.grid.major = element_blank(), 
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), 
                       axis.text = element_text(size = 12, colour = "black"), axis.title = element_text(size = 14))))
taxa_nested_sma_fitted_resid$fitted_resid_plot
```

#### Normality

```{r}
taxa_nested_sma_fitted_resid_qq <- taxa_nested_sma_fitted_resid |>
  mutate(qq = map2(.x = sma_object,
                  .y = taxa_clean,
                  .f = ~ plot(.x, which = "qq", main = paste("qq-plot:",.y))))
```

## Excluding outliers

### Running SMA's on untransformed data

```{r}
taxa_nested_sma_outliers_removed <- biomass_frozen_outliers_identified |> 
  filter(keep_data == TRUE) |>
  group_nest(taxa_clean) |>
  mutate(sma_object = map(.x = data,
                          ~ sma(dm_g ~ wm_g, data = .x)))
```

### Checking assumptions

#### Homogeneity of variance

```{r}
taxa_nested_sma_outliers_removed_fitted_resid <- taxa_nested_sma_outliers_removed |> 
  mutate(fitted_resid = map(.x = sma_object,
                             .f = ~ tibble(fitted = fitted(.x), residuals = residuals(.x))),
         fitted_resid_plot = map2(.x = fitted_resid,
                     .y = taxa_clean,
                     .f = ~ ggplot(data = .x, aes(x = fitted, y = residuals)) + 
                       ggtitle(.y) +
                       labs(x = "fitted value", y = "residual") +
                       geom_point() + 
                       geom_hline(yintercept = 0, linetype = 2) +
                       theme_bw() + 
                       theme(panel.border = element_blank(), panel.grid.major = element_blank(), 
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), 
                       axis.text = element_text(size = 12, colour = "black"), axis.title = element_text(size = 14))))
taxa_nested_sma_outliers_removed_fitted_resid$fitted_resid_plot
```

#### Normality

```{r}
taxa_nested_sma_outliers_removed_fitted_resid_qq <- taxa_nested_sma_outliers_removed_fitted_resid |>
  mutate(qq = map2(.x = sma_object,
                  .y = taxa_clean,
                  .f = ~ plot(.x, which = "qq", main = paste("qq-plot:",.y))))
```

## Testing error structure

Testing the error structure of the data to see whether non-linear (additive error) or log-normal (multiplicative error) models are more appropriate, using code from Xiao et al. (2011)

```{r}
taxa_nested_power_analysis_check <- biomass_frozen_outliers_identified |> 
  group_nest(taxa_clean) |>
  mutate(power_analysis_test = map(.x = data,
                          ~ power_analysis(.x$wm_g, .x$dm_g)))
```

## Log-transforming to stabilise variance and improve normality

### Running SMA's on log10-transformed data and plotting

```{r}
taxa_nested_sma_log10_plot <- biomass_frozen_outliers_identified |> 
  group_nest(taxa_clean) |>
  mutate(sma_log10_object = map(.x = data,
                          ~ sma(dm_g ~ wm_g, log = "xy", data = .x)),
         sma_log10_plots = map2(.x = sma_log10_object,
                         .y = taxa_clean,
                         .f = ~ plot(.x, xlab = "wet mass (g)", ylab = "dry mass (g)", main = .y)))
         
taxa_nested_sma_log10_plot$sma_log10_object
```

### Checking assumptions again

#### Homogeneity of variance

```{r}
taxa_nested_sma_log10_plot_fitted_resid <- taxa_nested_sma_log10_plot |> 
  mutate(fitted_resid = map(.x = sma_log10_object,
                             .f = ~ tibble(fitted = fitted(.x), residuals = residuals(.x))),
         fitted_resid_plot = map2(.x = fitted_resid,
                     .y = taxa_clean,
                     .f = ~ ggplot(data = .x, aes(x = fitted, y = residuals)) + 
                       ggtitle(.y) +
                       labs(x = "fitted value", y = "residual") +
                       geom_point() + 
                       geom_hline(yintercept = 0, linetype = 2) +
                       theme_bw() + 
                       theme(panel.border = element_blank(), panel.grid.major = element_blank(), 
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), 
                       axis.text = element_text(size = 12, colour = "black"), axis.title = element_text(size = 14))))
taxa_nested_sma_log10_plot_fitted_resid$fitted_resid_plot
```

#### Normality

```{r}
taxa_nested_sma_log10_plot_fitted_resid_qq <- taxa_nested_sma_log10_plot_fitted_resid |>
  mutate(qq = map2(.x = sma_log10_object,
                  .y = taxa_clean,
                  .f = ~ plot(.x, which = "qq", main = paste("qq-plot:",.y))))
```

### Regression summary statistics

Pulling out regression summary statistics

```{r}
# Getting coefficients from SMA
taxa_nested_sma_log10_plot_coef <- taxa_nested_sma_log10_plot |>
  mutate(summary = map(.x = sma_log10_object,
                       .f = ~ (smatr:::summary.sma(.x))))

long_summary <- taxa_nested_sma_log10_plot_coef |> 
  select(taxa_clean, summary) |> 
  unnest(summary) |> 
  select(taxa_clean, n, r2, pval, Slope, Slope_lowCI, Slope_highCI, Int, Int_lowCI, Int_highCI)

# Back-transforming intercept and confidence intervals to get parameter 'a' in power equation: y = ax^b
long_summary_a <- long_summary |> 
  mutate(a = 10^Int,
         a_low_ci = 10^Int_lowCI,
         a_high_ci = 10^Int_highCI)
```

Calculating SF (smearing factor - mean of back-transformed residuals) as per Mährlein, M., M. Pätzig, M. Brauns and A. M. Dolman. Length–mass relationships for lake macroinvertebrates corrected for back-transformation and preservation effects. Hydrobiologia, 768, 37-50 (2016).

```{r}
taxa_nested_sma_log10_plot_coef_sf <- taxa_nested_sma_log10_plot_coef |>
  mutate(sf = map(.x = sma_log10_object,
                  .f = ~ (1/length(residuals(.x)))*sum(10^residuals(.x))))

taxa_sf <- taxa_nested_sma_log10_plot_coef_sf |>
  select(taxa_clean, sf) |>
  unnest(sf)

# Adding smearing factor to SMA summary table
long_summary_a_sf <- merge(long_summary_a, taxa_sf)
```

### Back-transformation 

Plotting back-transformed regression equation with smearing factor correction

```{r}
taxa_nested_sma_log10_plot_coef_BT <- taxa_nested_sma_log10_plot_coef_sf |> 
  unnest(c(data, summary, sf)) |>
  mutate(lower_CI_line = (10^Int_lowCI)*(wm_g^Slope_lowCI)*sf,
         upper_CI_line = (10^Int_highCI)*(wm_g^Slope_highCI)*sf) |>
  nest(data = c(wm_g, dm_g, lower_CI_line, upper_CI_line, keep_data)) |>
  select(taxa_clean, data, Slope, Slope_lowCI, Slope_highCI, Int, Int_lowCI, Int_highCI, sf) |>
  mutate(BT_plot = pmap(.l = list(data, Slope, Slope_lowCI, Slope_highCI, Int, Int_lowCI, Int_highCI, sf, taxa_clean),
                        .f = ~ggplot(..1, aes(x = wm_g, y = dm_g)) +
                          geom_point() +
                          geom_function(fun = function(x) (10^..5)*(x^..2)*..8, 
                                        col = "darkgreen", linewidth  = 1) +
                          geom_ribbon(aes(ymin = lower_CI_line, ymax = upper_CI_line), fill = "darkgreen", alpha = 0.2) +
                          ggtitle(..9) + 
  labs(x = "wet mass (g)", y = "dry mass (g)") + 
  theme_bw() + 
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
          axis.text = element_text(size = 12, colour = "black"), axis.title = element_text(size = 14), title = element_text(size = 16)) +
     geom_text(x = 1, y = 1, label = (paste("dry mass = x "^eval(..2)*"")), parse = TRUE)))
          #    format(round(summary(bridled_goby_loglm)$adj.r.squared, 3), nsmall = 3))))
taxa_nested_sma_log10_plot_coef_BT$BT_plot
```

### Calculating biomass ratios and associated summary statistics

```{r}
biomass_frozen_outliers_identified_ratios <- biomass_frozen_outliers_identified |>
  mutate(dm_wm = dm_g/wm_g)
  
biomass_frozen_outliers_identified_ratios |>
  group_by(taxa_clean) |>
  summarise(n = n(),
            mean_dm_wm = mean(dm_wm),
            sd_dm_wm = sd(dm_wm),
            lower_ci_mean_dm_wm = mean_dm_wm-0.95*(sd_dm_wm/sqrt(n)),
            upper_ci_mean_dm_wm = mean_dm_wm+0.95*(sd_dm_wm/sqrt(n)),
            geom_mean = prod(dm_wm)^(1/n),
            min_dm_wm = min(dm_wm),
            median_dm_wm = median(dm_wm),
            max_dm_wm = max(dm_wm))
```

## Excluding outlier candidates

### Running SMA's on log10-transformed data and plotting

```{r}
taxa_nested_outliers_removed_sma_log10_plot <- biomass_frozen_outliers_identified |> 
  filter(keep_data == TRUE) |>
  group_nest(taxa_clean) |>
  mutate(sma_log10_object = map(.x = data,
                          ~ sma(dm_g ~ wm_g, log = "xy", data = .x)),
         sma_log10_plots = map2(.x = sma_log10_object,
                         .y = taxa_clean,
                         .f = ~ plot(.x, xlab = "wet mass (g)", ylab = "dry mass (g)", main = .y)))
taxa_nested_sma_log10_plot$sma_log10_plots
```

### Checking assumptions again

#### Homogeneity of variance

```{r}
taxa_nested_outliers_removed_sma_log10_plot_fitted_resid <- taxa_nested_outliers_removed_sma_log10_plot |> 
  mutate(fitted_resid = map(.x = sma_log10_object,
                             .f = ~ tibble(fitted = fitted(.x), residuals = residuals(.x))),
         fitted_resid_plot = map2(.x = fitted_resid,
                     .y = taxa_clean,
                     .f = ~ ggplot(data = .x, aes(x = fitted, y = residuals)) + 
                       ggtitle(.y) +
                       labs(x = "fitted value", y = "residual") +
                       geom_point() + 
                       geom_hline(yintercept = 0, linetype = 2) +
                       theme_bw() + 
                       theme(panel.border = element_blank(), panel.grid.major = element_blank(), 
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), 
                       axis.text = element_text(size = 12, colour = "black"), axis.title = element_text(size = 14))))
taxa_nested_outliers_removed_sma_log10_plot_fitted_resid$fitted_resid_plot
```

#### Normality

```{r}
taxa_nested_outliers_removed_sma_log10_plot_fitted_resid_qq <- taxa_nested_outliers_removed_sma_log10_plot_fitted_resid |>
  mutate(qq = map2(.x = sma_log10_object,
                  .y = taxa_clean,
                  .f = ~ plot(.x, which = "qq", main = paste("qq-plot:",.y))))
taxa_nested_outliers_removed_sma_log10_plot_fitted_resid_qq$qq
```

### Regression summary statistics

Pulling out regression summary statistics

```{r}
# Getting coefficients from SMA
taxa_nested_outliers_removed_sma_log10_plot_coef <- taxa_nested_outliers_removed_sma_log10_plot |>
  mutate(summary = map(.x = sma_log10_object,
                       .f = ~ (smatr:::summary.sma(.x))))

long_summary_outliers_removed <- taxa_nested_outliers_removed_sma_log10_plot_coef |> 
  select(taxa_clean, summary) |> 
  unnest(summary) |> 
  select(taxa_clean, n, r2, pval, Slope, Slope_lowCI, Slope_highCI, Int, Int_lowCI, Int_highCI)

# Back-transforming intercept and confidence intervals to get parameter 'a' in power equation: y = ax^b
long_summary_a_outliers_removed <- long_summary_outliers_removed |> 
  mutate(a = 10^Int,
         a_low_ci = 10^Int_lowCI,
         a_high_ci = 10^Int_highCI)
```

Calculating SF (smearing factor - mean of back-transformed residuals) as per Mährlein, M., M. Pätzig, M. Brauns and A. M. Dolman. Length–mass relationships for lake macroinvertebrates corrected for back-transformation and preservation effects. Hydrobiologia, 768, 37-50 (2016).3

```{r}
taxa_nested_outliers_removed_sma_log10_plot_coef_sf <- taxa_nested_outliers_removed_sma_log10_plot_coef |>
  mutate(sf = map(.x = sma_log10_object,
                  .f = ~ (1/length(residuals(.x)))*sum(10^residuals(.x))))

taxa_sf_outliers_removed <- taxa_nested_outliers_removed_sma_log10_plot_coef_sf |>
  select(taxa_clean, sf) |>
  unnest(sf)

# Adding smearing factor to SMA summary table
long_summary_a_sf_outliers_removed <- merge(long_summary_a_outliers_removed, taxa_sf_outliers_removed)
```

### Back-transformation 

Plotting back-transformed regression equation, with and without smearing factor correction

```{r}
taxa_nested_outliers_removed_sma_log10_plot_coef_sf_BT <- taxa_nested_outliers_removed_sma_log10_plot_coef_sf |> 
  unnest(c(data, summary, sf)) |>
  mutate(lower_CI_line = (10^Int_lowCI)*(wm_g^Slope_lowCI)*sf,
         upper_CI_line = (10^Int_highCI)*(wm_g^Slope_highCI)*sf) |>
  nest(data = c(wm_g, dm_g, lower_CI_line, upper_CI_line, keep_data)) |>
  select(taxa_clean, data, Slope, Slope_lowCI, Slope_highCI, Int, Int_lowCI, Int_highCI, sf) |>
  mutate(BT_plot = pmap(.l = list(data, Slope, Slope_lowCI, Slope_highCI, Int, Int_lowCI, Int_highCI, sf, taxa_clean),
                        .f = ~ggplot(..1, aes(x = wm_g, y = dm_g)) +
                          geom_point() +
                          geom_function(fun = function(x) (10^..5)*x^..2) +
                          geom_function(fun = function(x) (10^..5)*(x^..2)*..8, 
                                        col = "darkgreen", linewidth  = 1) +
                          geom_ribbon(aes(ymin = lower_CI_line, ymax = upper_CI_line), fill = "darkgreen", alpha = 0.2) +
                          ggtitle(..9)))
taxa_nested_outliers_removed_sma_log10_plot_coef_sf_BT$BT_plot
```

### Calculating biomass ratios and associated summary statistics

```{r}
biomass_frozen_outliers_removed_ratios <- biomass_frozen_outliers_identified |>
  filter(keep_data == TRUE) |>
  mutate(dm_wm = dm_g/wm_g)
  
biomass_frozen_outliers_removed_ratios |>
  group_by(taxa_clean) |>
  summarise(n = n(),
            mean_dm_wm = mean(dm_wm),
            sd_dm_wm = sd(dm_wm),
            lower_ci_mean_dm_wm = mean_dm_wm-0.95*(sd_dm_wm/sqrt(n)),
            upper_ci_mean_dm_wm = mean_dm_wm+0.95*(sd_dm_wm/sqrt(n)),
            geom_mean = prod(dm_wm)^(1/n),
            min_dm_wm = min(dm_wm),
            median_dm_wm = median(dm_wm),
            max_dm_wm = max(dm_wm))
```


Code from Xiao et al. (2011):
```{r}
power_analysis = function(x, y, CI_boot = TRUE, diagno = TRUE, output_plot = FALSE){
  ## Step 1: Likelihood analysis
  model_lr = lm(log(y) ~ log(x))
  a_lr = exp(coef(summary(model_lr))[1, 1])
  b_lr = coef(summary(model_lr))[2, 1]
  sd_lr = sd(log(y) - (log(a_lr) + b_lr * log(x)))
  
  model_nlr = nls(y ~ a1 * x ^ a2, start = list(a1 = a_lr, a2 = b_lr),
                  control = nls.control(maxiter = 2000, warnOnly = TRUE))
  a_nlr = coef(summary(model_nlr))[1, 1]
  b_nlr = coef(summary(model_nlr))[2, 1]
  sd_nlr = sd(y - a_nlr * x ^ b_nlr)
  
  l_logn = sum(log(dlnorm(y, log(a_lr * x ^ b_lr), sd_lr)))
  l_norm = sum(log(dnorm(y, a_nlr * x ^ b_nlr, sd_nlr)))
  
  n = length(x)
  k = 3
  AICc_logn = 2 * k - 2 * l_logn + 2 * k * (k + 1) / (n - k - 1)
  AICc_norm = 2 * k - 2 * l_norm + 2 * k * (k + 1) / (n - k - 1)
  delta_AICc = AICc_norm - AICc_logn
  writeLines(paste("AICc_logn: ", AICc_logn, "\nAICc_norm: ", AICc_norm))
  w_logn = exp(-(AICc_logn - min(AICc_logn, AICc_norm)) / 2)
  w_norm = exp(-(AICc_norm - min(AICc_logn, AICc_norm)) / 2)
  weight_logn = w_logn / (w_logn + w_norm)
  weight_norm = w_norm / (w_logn + w_norm)
  
  ## Step 2a: Analysis with NLR
  if (delta_AICc < - 2){
    writeLines("The assumption of additive normal error is better supported. \nProceed with NLR.")
    method = "NLR"
    a = a_nlr
    b = b_nlr
    a_confint = confint2(model_nlr)[1, ]
    b_confint = confint2(model_nlr)[2, ]
  }
  ## Step 2b: Analysis with LR
  else if (delta_AICc > 2){
    writeLines("The assumption of multiplicative log-normal error is better supported. \nProceed with LR.")
    method = "LR"
    a = a_lr
    b = b_lr
    a_confint = confint(model_lr)[1, ]
    b_confint = confint(model_lr)[2, ]
  }
  ## Step 2c: Analysis with model averaging
  else {
    writeLines("The two error distributions have similar support. \nProceed with model averaging.")
    method = "Model Averaging"
    a = a_lr * weight_logn + a_nlr * weight_norm
    b = b_lr * weight_logn + b_nlr * weight_norm
    if (!CI_boot){
      a_confint = NA
      b_confint = NA
    }
    else {
      boot.est=function(dat, indices) {
        dat.sub=dat[indices, ]
        names(dat.sub) = c("x", "y")
        model.lr = lm(log(y) ~ log(x), dat = dat.sub)
        a.lr = exp(coef(summary(model.lr))[1, 1])
        b.lr = coef(summary(model.lr))[2, 1]
        sd.lr = sd(log(dat.sub$y) - (log(a.lr) + b.lr * log(dat.sub$x)))
        a.lr.CI = confint(model.lr)[1, ]
        b.lr.CI = confint(model.lr)[2, ]
        model.nlr = nls(y ~ a1 * x ^ a2, start = list(a1 = a.lr, a2 = b.lr), dat = dat.sub,
                        control = nls.control(maxiter = 2000, warnOnly = TRUE))
        a.nlr = coef(summary(model.nlr))[1, 1]
        b.nlr = coef(summary(model.nlr))[2, 1]
        sd.nlr = sd(dat.sub$y - a.nlr * dat.sub$x ^ b.nlr)
        a.nlr.CI = confint2(model.nlr)[1, ]
        b.nlr.CI = confint2(model.nlr)[2, ]
        
        l.logn = sum(log(dlnorm(dat.sub$y, log(a.lr * dat.sub$x ^ b.lr), sd.lr)))
        l.norm = sum(log(dnorm(dat.sub$y, a.nlr * dat.sub$x ^ b.nlr, sd.nlr)))
        AICc.logn = 2 * k - 2 * l.logn + 2 * k * (k + 1) / (n - k - 1)
        AICc.norm = 2 * k - 2 * l.norm + 2 * k * (k + 1) / (n - k - 1)
        AICc.min = min(AICc.logn, AICc.norm)
        weight.logn = exp(-(AICc.logn - AICc.min)/2)
        weight.norm = exp(-(AICc.norm - AICc.min)/2)
        logn.w = weight.logn / (weight.logn + weight.norm)
        norm.w = weight.norm / (weight.logn + weight.norm)
        
        a.boot = a.lr * logn.w + a.nlr * norm.w
        b.boot = b.lr * logn.w + b.nlr * norm.w
        return(c(a.boot, b.boot))
      }
      dat.boot=boot(data = as.data.frame(cbind(x, y)), statistic = boot.est, R = 1000)
      a_confint = boot.ci(dat.boot, index = 1, type = "perc")$perc[4:5]
      b_confint = boot.ci(dat.boot, index = 2, type = "perc")$perc[4:5]
    }
  }
  writeLines(paste("a: ", a, "\nb: ", b))
  
  ## Step 3: residual plots as visual diagnostics
  if (diagno){
    lr_res = resid(model_lr)
    lr_pred = predict(model_lr)
    nlr_res = resid(model_nlr)
    nlr_pred = predict(model_nlr)
    par(mfrow = c(2, 2), oma = c(0, 4, 2, 0))
    hist(lr_res, freq = FALSE, main = "", xlab = "Residuals")
    curve(dnorm(x, mean(lr_res), sd(lr_res)), add = TRUE)
    plot(lr_pred, lr_res, xlab = "Predicted y", ylab = "Residuals")
    abline(h = 0)
    hist(nlr_res, freq = FALSE, main = "", xlab = "Residuals")
    curve(dnorm(x, mean(nlr_res), sd(nlr_res)), add = TRUE)
    plot(nlr_pred, nlr_res, xlab = "Predicted y", ylab = "Residuals")
    abline(h = 0)
    mtext("      Normality                                            Homoscedasticity", 
          cex = 1.5, side = 3, outer = TRUE)
    mtext("NLR                                        LR", cex = 1.5, side = 2, outer = TRUE)
  }
  if (output_plot){                                                                                                                   
    par(mfrow = c(1, 2), oma = c(0, 4, 2, 0))
    plot(x, y, log = "xy", xlab = "x", ylab = "y", pch = 20, main = "Logarithmic Scale")
    curve(a * x ^ b, add = TRUE, lty = "dashed")
    plot(x, y, xlab = "x", ylab = "y", pch = 20, main = "Arithmetic Scale")
    curve(a * x ^ b, add = TRUE, lty = "dashed")
    title(main = paste("Fitting Power-Law Data with ", method), outer = TRUE)
  }
  
  return (list(method = method, a = a, b = b, a_confint = a_confint, b_confint = b_confint))
}
```
