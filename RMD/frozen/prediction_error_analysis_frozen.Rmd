---
title: "prediction error"
author: "Josh Nitschke"
date: "2023-10-10"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# install.packages("remotes")
remotes::install_github("traitecoevo/smatr")

library(tidyverse)
library(here)
library(janitor)
library(skimr)
library(purrr)
library(tidyr)
library(smatr)

```

# Wet mass as a predictor of dry mass

## Reading in cleaned data

```{r}
biomass_frozen_wm_dm_cleaned <- read_csv(here("data/processed/frozen/wm_dm/biomass_frozen_wm_dm_cleaned.csv"))
```

## OLS

### Regression summary statistics

Excluding outliers, running linear regressions on log-transformed data, and pulling out regression summary statistics

```{r}
# Getting coefficients from lm
taxa_nested_lm_ln_coef_frozen_wm_dm <- biomass_frozen_wm_dm_cleaned |>
  filter(keep_data == TRUE) |>
  group_nest(taxa_clean) |>
  mutate(lm_ln_object = map(.x = data,
                         .f = ~ lm(log(dm_g) ~ log(wm_g), data = .x)),
         summary = map(.x = lm_ln_object,
                       .f = ~ summary(.x)))
long_summary_frozen_wm_dm <- taxa_nested_lm_ln_coef_frozen_wm_dm |>
  mutate(coefs = map(.x = summary,
                            ~.x[[4]]),
         r2 = map(.x = summary,
                            ~.x[[9]]),
         n = map(.x = lm_ln_object,
                 ~length(.x$residuals))) |>
  unnest(c(coefs, r2, n)) |>
  mutate(coef_type = c(rep(c("intercept", "slope"), times = length(taxa_clean)/2))) |>
  pivot_wider(names_from = coef_type, values_from = coefs)

intercept <- long_summary_frozen_wm_dm$intercept[,1]
intercept_se <- long_summary_frozen_wm_dm$intercept[,2]
slope <- long_summary_frozen_wm_dm$slope[,1]
slope_se <- long_summary_frozen_wm_dm$slope[,2]
p <- long_summary_frozen_wm_dm$slope[,4] # p-value of the slope is the same as the p-vale of the overall regression model in the case of simple regression with one predictor
long_summary_frozen_wm_dm_short <- long_summary_frozen_wm_dm |>
  select(taxa_clean, n, r2)
  
reg_summary_frozen_wm_dm <- add_column(long_summary_frozen_wm_dm_short, tibble(intercept, intercept_se, slope, slope_se, p))

# Back-transforming intercept to get parameter 'a' in power equation: y = ax^b
reg_summary_frozen_wm_dm_a <- reg_summary_frozen_wm_dm |> 
  mutate(a = exp(intercept))
```

Calculating SF (smearing factor - mean of back-transformed residuals) as per Mährlein, M., M. Pätzig, M. Brauns and A. M. Dolman. Length–mass relationships for lake macroinvertebrates corrected for back-transformation and preservation effects. Hydrobiologia, 768, 37-50 (2016).

```{r}
taxa_nested_lm_ln_coef_sf_frozen_wm_dm <- taxa_nested_lm_ln_coef_frozen_wm_dm |>
  mutate(sf = map(.x = lm_ln_object,
                  .f = ~ (1/length(residuals(.x)))*sum(exp(residuals(.x)))))

taxa_sf_frozen_wm_dm <- taxa_nested_lm_ln_coef_sf_frozen_wm_dm |>
  select(taxa_clean, sf) |>
  unnest(sf)

# Adding smearing factor to lm summary table
reg_summary_frozen_wm_dm_a_sf <- merge(reg_summary_frozen_wm_dm_a, taxa_sf_frozen_wm_dm)

```

## SMA

### Regression summary statistics

Pulling out regression summary statistics

```{r}
# Getting coefficients from SMA
taxa_nested_sma_ln_coef_frozen_wm_dm <- biomass_frozen_wm_dm_cleaned |>
  filter(keep_data == TRUE) |>
  group_nest(taxa_clean) |>
  mutate(sma_ln_object = map(.x = data,
                         .f = ~ sma(log(dm_g) ~ log(wm_g), data = .x)),
         summary = map(.x = sma_ln_object,
                       .f = ~ (smatr:::summary.sma(.x))))

sma_summary_frozen_wm_dm <- taxa_nested_sma_ln_coef_frozen_wm_dm |> 
  select(taxa_clean, summary) |> 
  unnest(summary) |> 
  select(taxa_clean, n, r2, pval, Slope, Slope_lowCI, Slope_highCI, Int, Int_lowCI, Int_highCI)

# Back-transforming intercept and confidence intervals to get parameter 'a' in power equation: y = ax^b
sma_summary_frozen_wm_dm_a <- sma_summary_frozen_wm_dm |> 
  mutate(a = exp(Int))
```

Calculating SF (smearing factor - mean of back-transformed residuals) as per Mährlein, M., M. Pätzig, M. Brauns and A. M. Dolman. Length–mass relationships for lake macroinvertebrates corrected for back-transformation and preservation effects. Hydrobiologia, 768, 37-50 (2016).

```{r}
taxa_nested_sma_ln_coef_sf_frozen_wm_dm <- taxa_nested_sma_ln_coef_frozen_wm_dm |>
  mutate(sf = map(.x = sma_ln_object,
                  .f = ~ (1/length(residuals(.x)))*sum(exp(residuals(.x)))))

taxa_sf_sma_frozen_wm_dm <- taxa_nested_sma_ln_coef_sf_frozen_wm_dm |>
  select(taxa_clean, sf) |>
  unnest(sf)

# Adding smearing factor to SMA summary table
sma_summary_frozen_wm_dm_a_sf <- merge(sma_summary_frozen_wm_dm_a,
                                            taxa_sf_sma_frozen_wm_dm)

# Adding suffix to variable names for later identification
names(sma_summary_frozen_wm_dm_a_sf) <- paste0(names(sma_summary_frozen_wm_dm_a_sf), "_sma")
sma_summary_frozen_wm_dm_a_sf <- rename(sma_summary_frozen_wm_dm_a_sf, "taxa_clean" = "taxa_clean_sma") |>
  clean_names()
```

### Calculating biomass ratios and associated summary statistics (outliers excluded)

```{r}
biomass_frozen_wm_dm_cleaned_ratios <- biomass_frozen_wm_dm_cleaned |>
  filter(keep_data == TRUE) |>
  mutate(dm_wm = dm_g/wm_g) |>
  group_by(taxa_clean) |>
  summarise(n = n(),
            mean_dm_wm = mean(dm_wm),
            sd_dm_wm = sd(dm_wm),
            lower_ci_mean_dm_wm = mean_dm_wm-0.95*(sd_dm_wm/sqrt(n)),
            upper_ci_mean_dm_wm = mean_dm_wm+0.95*(sd_dm_wm/sqrt(n)),
            geom_mean = prod(dm_wm)^(1/n),
            min_dm_wm = min(dm_wm),
            median_dm_wm = median(dm_wm),
            max_dm_wm = max(dm_wm))
```

## Comparing error in predicted mass for regression and ratio methods

```{r cars}
total_pred_mass_frozen_wm_dm <- taxa_nested_lm_ln_coef_sf_frozen_wm_dm |>
  right_join(reg_summary_frozen_wm_dm_a) |>
  right_join(sma_summary_frozen_wm_dm_a_sf) |>
  mutate(total_dm = map(.x = data,
                        .f = ~sum(.x$dm_g)),
         total_reg_pred_dm = pmap(.l = list(data, a, slope, sf),
                            .f = ~ sum(..2*(..1$wm_g)^..3)*..4),
         total_reg_pred_dm_percent_error = map2(.x = total_dm,
                                          .y = total_reg_pred_dm,
                                          .f = ~-((.x-.y)/.x)*100),
         total_sma_pred_dm = pmap(.l = list(data, a_sma, slope_sma, sf_sma),
                            .f = ~ sum(..2*(..1$wm_g)^..3)*..4),
         total_sma_pred_dm_percent_error = map2(.x = total_dm,
                                          .y = total_sma_pred_dm,
                                          .f = ~-((.x-.y)/.x)*100),
         total_ratio_pred_dm = map2(.x = data,
                              .y = biomass_frozen_wm_dm_cleaned_ratios$mean_dm_wm,
                              .f = ~ sum(.y*.x$wm_g)),
         total_ratio_pred_dm_percent_error = map2(.x = total_dm,
                                          .y = total_ratio_pred_dm,
                                          .f = ~-((.x-.y)/.x)*100))
         
total_pred_mass_frozen_wm_dm_error <- total_pred_mass_frozen_wm_dm |>
  select(taxa_clean, total_dm, total_reg_pred_dm, total_reg_pred_dm_percent_error, 
         total_sma_pred_dm, total_sma_pred_dm_percent_error,
         total_ratio_pred_dm, total_ratio_pred_dm_percent_error) |>
  unnest(cols = c(total_dm, total_reg_pred_dm, total_reg_pred_dm_percent_error, 
                  total_sma_pred_dm, total_sma_pred_dm_percent_error,
                  total_ratio_pred_dm, total_ratio_pred_dm_percent_error))

total_pred_mass_frozen_wm_dm_error_long <- total_pred_mass_frozen_wm_dm_error |>
  select(taxa_clean, total_reg_pred_dm_percent_error, total_sma_pred_dm_percent_error,
         total_ratio_pred_dm_percent_error) |>
  pivot_longer(cols = c(total_reg_pred_dm_percent_error, total_sma_pred_dm_percent_error,
                        total_ratio_pred_dm_percent_error), 
               names_to = "pred_method", values_to = "percent_error")
  
ggplot(data = total_pred_mass_frozen_wm_dm_error_long, aes(x = pred_method, y = percent_error)) +
  geom_jitter(width = 0.1, size = 3, fill = "grey", alpha = 0.5, stroke = 1) + 
  geom_hline(yintercept = 0, linetype = 2) +
  ggtitle("wet mass -> dry mass") +
  labs(x = "prediction method", y = "percentage error in total mass") +
  scale_x_discrete(labels = c("mean ratio", 
                              "OLS regression (log-linear)", 
                              "SMA regression (log-linear)")) +
    theme_bw() +
    theme(panel.border = element_blank(), 
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(), 
          axis.line = element_line(colour = "black"),
          axis.text = element_text(size = 12, colour = "black"), 
          axis.title = element_text(size = 14))
```

## Prediction error as a function of mass

```{r}
pred_mass_frozen_wm_dm <- total_pred_mass_frozen_wm_dm |>
  mutate(ols_pred_dm = pmap(.l = list(data, a, slope, sf),
                            .f = ~ ..2*(..1$wm_g)^..3*..4),
         ols_pred_dm_percent_error = map2(.x = data,
                                          .y = ols_pred_dm,
                                          .f = ~-((.x$dm_g-.y)/.x$dm_g)*100),
         ratio_pred_dm = map2(.x = data,
                              .y = biomass_frozen_wm_dm_cleaned_ratios$mean_dm_wm,
                              .f = ~ .y*.x$wm_g),
         ratio_pred_dm_percent_error = map2(.x = data,
                                          .y = ratio_pred_dm,
                                          .f = ~-((.x$dm_g-.y)/.x$dm_g)*100))

pred_mass_frozen_wm_dm_plot <- pred_mass_frozen_wm_dm |>
  unnest(cols = c(data, ols_pred_dm_percent_error, ratio_pred_dm_percent_error)) |>
  group_nest(taxa_clean) |>
  mutate(ols_pred_dm_percent_error_plot = map2(.x = data, 
                                               .y = taxa_clean,
                                               .f = ~ ggplot(.x, aes(x = wm_g, y = ols_pred_dm_percent_error)) +
                                                 geom_point() + 
                                                 geom_hline(yintercept = 0, linetype = 2) +
                                                 ggtitle(.y)),
         ratio_pred_dm_percent_error_plot = map2(.x = data, 
                                               .y = taxa_clean,
                                               .f = ~ ggplot(.x, aes(x = wm_g, y = ratio_pred_dm_percent_error)) +
                                                 geom_point() + 
                                                 geom_hline(yintercept = 0, linetype = 2) +
                                                 ggtitle(.y)))
pred_mass_frozen_wm_dm_plot$ols_pred_dm_percent_error_plot
pred_mass_frozen_wm_dm_plot$ratio_pred_dm_percent_error_plot

```

## Mean Absolute Prediction Error

```{r}
pred_mass_frozen_wm_dm_MAPE <- pred_mass_frozen_wm_dm |>
mutate(ols_MAPE = map2(.x = ols_pred_dm_percent_error,
                       .y = n,
                       .f = ~ sum(abs(.x))/.y),
       ratio_MAPE = map2(.x = ratio_pred_dm_percent_error,
                       .y = n,
                       .f = ~ sum(abs(.x))/.y))
pred_mass_frozen_wm_dm_MAPE |> select(taxa_clean, ols_MAPE, ratio_MAPE) |> unnest(ols_MAPE, ratio_MAPE)
```


# individual count as a predictor of wet mass

## Reading in cleaned data

```{r}
biomass_frozen_count_wm_cleaned <- read_csv(here("data/processed/frozen/count_wm/biomass_frozen_count_wm_cleaned.csv"))
```

### Regression summary statistics

Excluding outliers, running linear regressions on log-transformed data, and pulling out regression summary statistics

```{r}
# Getting coefficients from lm
taxa_nested_lm_ln_coef_frozen_count_wm <- biomass_frozen_count_wm_cleaned |>
  filter(keep_data == TRUE) |>
  group_nest(taxa_clean) |>
  mutate(lm_ln_object = map(.x = data,
                            .f = ~ lm(log(wm_g) ~ log(individual_count), data = .x)),
         summary = map(.x = lm_ln_object,
                       .f = ~ summary(.x)))
long_summary_frozen_count_wm <- taxa_nested_lm_ln_coef_frozen_count_wm |>
  mutate(coefs = map(.x = summary,
                     ~.x[[4]]),
         r2 = map(.x = summary,
                  ~.x[[9]]),
         n = map(.x = lm_ln_object,
                 ~length(.x$residuals))) |>
  unnest(c(coefs, r2, n)) |>
  mutate(coef_type = c(rep(c("intercept", "slope"), times = length(taxa_clean)/2))) |>
  pivot_wider(names_from = coef_type, values_from = coefs)

intercept <- long_summary_frozen_count_wm$intercept[,1]
intercept_se <- long_summary_frozen_count_wm$intercept[,2]
slope <- long_summary_frozen_count_wm$slope[,1]
slope_se <- long_summary_frozen_count_wm$slope[,2]
p <- long_summary_frozen_count_wm$slope[,4] # p-value of the slope is the same as the p-vale of the overall regression model in the case of simple regression with one predictor
long_summary_frozen_count_wm_short <- long_summary_frozen_count_wm |>
  select(taxa_clean, n, r2)

reg_summary_frozen_count_wm <- add_column(long_summary_frozen_count_wm_short, tibble(intercept, intercept_se, slope, slope_se, p))

# Back-transforming intercept to get parameter 'a' in power equation: y = ax^b
reg_summary_frozen_count_wm_a <- reg_summary_frozen_count_wm |> 
  mutate(a = exp(intercept))
```

Calculating SF (smearing factor - mean of back-transformed residuals) as per Mährlein, M., M. Pätzig, M. Brauns and A. M. Dolman. Length–mass relationships for lake macroinvertebrates corrected for back-transformation and preservation effects. Hydrobiologia, 768, 37-50 (2016).

```{r}
taxa_nested_lm_ln_coef_sf_frozen_count_wm <- taxa_nested_lm_ln_coef_frozen_count_wm |>
  mutate(sf = map(.x = lm_ln_object,
                  .f = ~ (1/length(residuals(.x)))*sum(exp(residuals(.x)))))

taxa_sf_frozen_count_wm <- taxa_nested_lm_ln_coef_sf_frozen_count_wm |>
  select(taxa_clean, sf) |>
  unnest(sf)

# Adding smearing factor to lm summary table
reg_summary_frozen_count_wm_a_sf <- merge(reg_summary_frozen_count_wm_a, taxa_sf_frozen_count_wm)

```

### Calculating biomass ratios and associated summary statistics (outliers excluded)

```{r}
biomass_frozen_count_wm_cleaned_ratios <- biomass_frozen_count_wm_cleaned |>
  filter(keep_data == TRUE) |>
  mutate(wm_count = wm_g/individual_count) |>
  group_by(taxa_clean) |>
  summarise(n = n(),
            mean_wm_count = mean(wm_count),
            sd_wm_count = sd(wm_count),
            lower_ci_mean_wm_count = mean_wm_count-0.95*(sd_wm_count/sqrt(n)),
            upper_ci_mean_wm_count = mean_wm_count+0.95*(sd_wm_count/sqrt(n)),
            geom_mean = prod(wm_count)^(1/n),
            min_wm_count = min(wm_count),
            median_wm_count = median(wm_count),
            max_wm_count = max(wm_count))
```

## Comparing error in predicted mass for regression and ratio methods

```{r cars}
pred_mass_frozen_count_wm <- taxa_nested_lm_ln_coef_sf_frozen_count_wm |>
  right_join(reg_summary_frozen_count_wm_a) |>
  mutate(total_wm = map(.x = data,
                        .f = ~sum(.x$wm_g)),
         reg_pred_wm = pmap(.l = list(data, a, slope, sf),
                            .f = ~ sum(..2*(..1$individual_count)^..3)*..4),
         reg_pred_wm_percent_error = map2(.x = total_wm,
                                          .y = reg_pred_wm,
                                          .f = ~-((.x-.y)/.x)*100),
         ratio_pred_wm = map2(.x = data,
                              .y = biomass_frozen_count_wm_cleaned_ratios$mean_wm_count,
                              .f = ~ sum(.y*.x$individual_count)),
         ratio_pred_wm_percent_error = map2(.x = total_wm,
                                            .y = ratio_pred_wm,
                                            .f = ~-((.x-.y)/.x)*100))

pred_mass_frozen_count_wm_error <- pred_mass_frozen_count_wm |>
  select(taxa_clean, total_wm, reg_pred_wm, reg_pred_wm_percent_error, 
         ratio_pred_wm, ratio_pred_wm_percent_error) |>
  unnest(cols = c(total_wm, reg_pred_wm, reg_pred_wm_percent_error, 
                  ratio_pred_wm, ratio_pred_wm_percent_error))

pred_mass_frozen_count_wm_error_long <- pred_mass_frozen_count_wm_error |>
  select(taxa_clean, reg_pred_wm_percent_error, ratio_pred_wm_percent_error) |>
  pivot_longer(cols = c(reg_pred_wm_percent_error, ratio_pred_wm_percent_error), names_to = "pred_method", values_to = "percent_error")

ggplot(data = pred_mass_frozen_count_wm_error_long, aes(x = pred_method, y = percent_error)) +
  geom_jitter(width = 0.1, size = 3, fill = "grey", alpha = 0.5, stroke = 1) + 
  geom_hline(yintercept = 0, linetype = 2) +
  ggtitle("count -> wet mass") +
  labs(x = "prediction method", y = "percentage error in total mass") +
  scale_x_discrete(labels = c("mean ratio", "log-linear regression")) +
  theme_bw() +
  theme(panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        axis.text = element_text(size = 12, colour = "black"), 
        axis.title = element_text(size = 14))
```

# individual count as a predictor of dry mass

## Reading in cleaned data

```{r}
biomass_frozen_count_dm_cleaned <- read_csv(here("data/processed/frozen/count_dm/biomass_frozen_count_dm_cleaned.csv"))
```

### Regression summary statistics

Excluding outliers, running linear regressions on log-transformed data, and pulling out regression summary statistics

```{r}
# Getting coefficients from lm
taxa_nested_lm_ln_coef_frozen_count_dm <- biomass_frozen_count_dm_cleaned |>
  filter(keep_data == TRUE) |>
  group_nest(taxa_clean) |>
  mutate(lm_ln_object = map(.x = data,
                            .f = ~ lm(log(dm_g) ~ log(individual_count), data = .x)),
         summary = map(.x = lm_ln_object,
                       .f = ~ summary(.x)))
long_summary_frozen_count_dm <- taxa_nested_lm_ln_coef_frozen_count_dm |>
  mutate(coefs = map(.x = summary,
                     ~.x[[4]]),
         r2 = map(.x = summary,
                  ~.x[[9]]),
         n = map(.x = lm_ln_object,
                 ~length(.x$residuals))) |>
  unnest(c(coefs, r2, n)) |>
  mutate(coef_type = c(rep(c("intercept", "slope"), times = length(taxa_clean)/2))) |>
  pivot_wider(names_from = coef_type, values_from = coefs)

intercept <- long_summary_frozen_count_dm$intercept[,1]
intercept_se <- long_summary_frozen_count_dm$intercept[,2]
slope <- long_summary_frozen_count_dm$slope[,1]
slope_se <- long_summary_frozen_count_dm$slope[,2]
p <- long_summary_frozen_count_dm$slope[,4] # p-value of the slope is the same as the p-vale of the overall regression model in the case of simple regression with one predictor
long_summary_frozen_count_dm_short <- long_summary_frozen_count_dm |>
  select(taxa_clean, n, r2)

reg_summary_frozen_count_dm <- add_column(long_summary_frozen_count_dm_short, tibble(intercept, intercept_se, slope, slope_se, p))

# Back-transforming intercept to get parameter 'a' in power equation: y = ax^b
reg_summary_frozen_count_dm_a <- reg_summary_frozen_count_dm |> 
  mutate(a = exp(intercept))
```

Calculating SF (smearing factor - mean of back-transformed residuals) as per Mährlein, M., M. Pätzig, M. Brauns and A. M. Dolman. Length–mass relationships for lake macroinvertebrates corrected for back-transformation and preservation effects. Hydrobiologia, 768, 37-50 (2016).

```{r}
taxa_nested_lm_ln_coef_sf_frozen_count_dm <- taxa_nested_lm_ln_coef_frozen_count_dm |>
  mutate(sf = map(.x = lm_ln_object,
                  .f = ~ (1/length(residuals(.x)))*sum(exp(residuals(.x)))))

taxa_sf_frozen_count_dm <- taxa_nested_lm_ln_coef_sf_frozen_count_dm |>
  select(taxa_clean, sf) |>
  unnest(sf)

# Adding smearing factor to lm summary table
reg_summary_frozen_count_dm_a_sf <- merge(reg_summary_frozen_count_dm_a, taxa_sf_frozen_count_dm)

```

### Calculating biomass ratios and associated summary statistics (outliers excluded)

```{r}
biomass_frozen_count_dm_cleaned_ratios <- biomass_frozen_count_dm_cleaned |>
  filter(keep_data == TRUE) |>
  mutate(dm_count = dm_g/individual_count) |>
  group_by(taxa_clean) |>
  summarise(n = n(),
            mean_dm_count = mean(dm_count),
            sd_dm_count = sd(dm_count),
            lower_ci_mean_dm_count = mean_dm_count-0.95*(sd_dm_count/sqrt(n)),
            upper_ci_mean_dm_count = mean_dm_count+0.95*(sd_dm_count/sqrt(n)),
            geom_mean = prod(dm_count)^(1/n),
            min_dm_count = min(dm_count),
            median_dm_count = median(dm_count),
            max_dm_count = max(dm_count))
```

## Comparing error in predicted mass for regression and ratio methods

```{r cars}
pred_mass_frozen_count_dm <- taxa_nested_lm_ln_coef_sf_frozen_count_dm |>
  right_join(reg_summary_frozen_count_dm_a) |>
  mutate(total_dm = map(.x = data,
                        .f = ~sum(.x$dm_g)),
         reg_pred_dm = pmap(.l = list(data, a, slope, sf),
                            .f = ~ sum(..2*(..1$individual_count)^..3)*..4),
         reg_pred_dm_percent_error = map2(.x = total_dm,
                                          .y = reg_pred_dm,
                                          .f = ~-((.x-.y)/.x)*100),
         ratio_pred_dm = map2(.x = data,
                              .y = biomass_frozen_count_dm_cleaned_ratios$mean_dm_count,
                              .f = ~ sum(.y*.x$individual_count)),
         ratio_pred_dm_percent_error = map2(.x = total_dm,
                                            .y = ratio_pred_dm,
                                            .f = ~-((.x-.y)/.x)*100))

pred_mass_frozen_count_dm_error <- pred_mass_frozen_count_dm |>
  select(taxa_clean, total_dm, reg_pred_dm, reg_pred_dm_percent_error, 
         ratio_pred_dm, ratio_pred_dm_percent_error) |>
  unnest(cols = c(total_dm, reg_pred_dm, reg_pred_dm_percent_error, 
                  ratio_pred_dm, ratio_pred_dm_percent_error))

pred_mass_frozen_count_dm_error_long <- pred_mass_frozen_count_dm_error |>
  select(taxa_clean, reg_pred_dm_percent_error, ratio_pred_dm_percent_error) |>
  pivot_longer(cols = c(reg_pred_dm_percent_error, ratio_pred_dm_percent_error), names_to = "pred_method", values_to = "percent_error")

ggplot(data = pred_mass_frozen_count_dm_error_long, aes(x = pred_method, y = percent_error)) +
  geom_jitter(width = 0.1, size = 3, fill = "grey", alpha = 0.5, stroke = 1) + 
  geom_hline(yintercept = 0, linetype = 2) +
  ggtitle("count -> dry mass") +
  labs(x = "prediction method", y = "percentage error in total mass") +
  scale_x_discrete(labels = c("mean ratio", "log-linear regression")) +
  theme_bw() +
  theme(panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        axis.text = element_text(size = 12, colour = "black"), 
        axis.title = element_text(size = 14))
```

