---
title: "R Notebook"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(here)
library(smatr)
library(janitor)
library(skimr)
library(gridExtra)
library(olsrr)
library(purrr)
library(tidyr)

source(here("R/func/clean_functions.R"))
```

# Read in data and create observation numer

```{r, warning=FALSE}
biomass_data_taxaclean <-
  read_csv(here("data/processed/biomass_data_cleannames.csv")) |> 
  mutate(obs_num = row_number())
```

## Pre-cleaning the data

setting minimum mass cut-off (due to higher proportional measurement error at very small mass values) and removing observations when wet mass is less than dry mass (considering these errors in measurement or recording)
```{r}
biomass_data_taxaclean_mass_cutoff <- biomass_data_taxaclean |>
   filter(wm_g >= 0.001, dm_g >=0.001, wm_g >= dm_g)
 
  # filter(wm_g >= 0.001, dm_g >=0.001, afdm_g >=0.001, wm_g >= dm_g, dm_g >= afdm_g) |>
  # select(source, taxa_clean, preservation_method, wm_g, dm_g, afdm_g) |>
  # print(n = Inf)

```

```{r}
step_1 <- min_cutoff(data = biomass_data_taxaclean, wm_g, dm_g)  
step_2 <- check_mass_diff(step_1,  wm_g, dm_g)
```

filtering frozen samples only
```{r}
step_3 <- step_2 |>
  filter(preservation_method == "Frozen")
```

filter taxa that have enough obs for analysis

find taxa less than 10 obs

```{r}
notenough_taxa <- step_3 |> 
  group_by(taxa_clean) |> 
  summarise(n = n()) |> 
  filter(n < 10) |> 
  pull(taxa_clean)

# Checking
step_3 |> 
    filter(! taxa_clean %in% notenough_taxa) |> 
  pull(taxa_clean) |> tabyl()
```


```{r}
taxa_notenough_obs(step_3, taxa_clean) |> 
  pull(taxa_clean) |> tabyl()
```

## Identifying outlier candidates

### Cleveland Plots
Creating Cleveland plots for each taxa as a visual tool to help identify observations that are far-removed from the rest.
```{r fig.height=15, fig.width=10}

step_3 |> ggplot(aes(x = wm_g, y = obs_num, label = obs_num)) +
  facet_wrap(~ taxa_clean, ncol = 4, scale = "free") +
  geom_point(colour = "white") +
  geom_text()

```

```{r}

```


### Percentage analysis 
Identifying top and bottom 2.5% of the data for each mass variable
```{r}

#biomass_frozen_percentiles <- biomass_wobs |>
#  mutate(keep_data_wm_percentiles = ifelse(wm_g >= quantile(wm_g, 0.025, na.rm = TRUE) & wm_g <= quantile(wm_g, #0.975, na.rm = TRUE), TRUE, FALSE),
#        keep_data_dm_percentiles = ifelse(dm_g >= quantile(dm_g, 0.025, na.rm = TRUE) & dm_g <= quantile(dm_g, #0.975, na.rm = TRUE), TRUE, FALSE))
  
biomass_percentiles <- function(mass_measure){
  ifelse(mass_measure >= quantile(mass_measure, 0.025, na.rm = TRUE) 
         & mass_measure <= quantile(mass_measure, 0.975, na.rm = TRUE), TRUE, FALSE)
}

biomass_frozen_percentiles <- step_3 |>
  group_by(taxa_clean) |>
  mutate(keep_data_mass1_percentiles = biomass_percentiles(wm_g),
         keep_data_mass2_percentiles = biomass_percentiles(dm_g))
  
# Checking which observations are identified by the percentile method
biomass_frozen_percentiles |> 
  filter(keep_data_mass1_percentiles == FALSE) |> 
  select(taxa_clean, wm_g, keep_data_mass1_percentiles, obs_num) |>
  arrange(taxa_clean, wm_g) |>
  print(n = Inf)
```

### Measures of outlyingness
Calculating measures of outlyingness and associated cutoff values for outlier identification
```{r}

#Nesting by taxa
taxa_nested <- biomass_frozen_percentiles |> 
  select(taxa_clean, wm_g, dm_g, obs_num, keep_data_wm_percentiles, keep_data_dm_percentiles) |> 
  nest(data = c(wm_g, dm_g, obs_num, keep_data_wm_percentiles, keep_data_dm_percentiles))
  
#Calculating measures of outlyingness and associated cutoff values
taxa_nested_outlier_measures <- taxa_nested |> 
  mutate(lm_object = map(.x = data,
                         ~ lm(dm_g ~ wm_g, data = .x)),
         n = map(.x = lm_object,
                 ~ nrow(.x$model)),
         predictors = map(.x = lm_object,
                          ~length(coef(.x))-1),
         leverage = map(.x = lm_object,
                        ~ hatvalues(.x)),
         leverage_cutoff = map2(.x = predictors,
                           .y = n,
                           ~ 2*(.x+1)/.y),
         stud_residual = map(.x = lm_object,
                             ~rstudent(.x)),
         alpha_tdist = map(.x = n,
                           ~0.05/.x),
         df_tdist = map2(.x = n,
                         .y = predictors,
                         ~.x-.y-1),
         critical_t = map2(.x = alpha_tdist,
                           .y = df_tdist,
                           ~qt(.x/2, .y, lower.tail = FALSE, log.p = FALSE)),
         cooks_d = map(.x = lm_object, 
                       ~ cooks.distance(.x)),
         cooks_d_cutoff = map2(.x = predictors,
                          .y = n,
                          ~qf(0.5, .x+1, .y-.x-1, lower.tail = FALSE)),
         dffits = map(.x = lm_object,
                      ~dffits(.x)),
         dffits_cutoff = map2(.x = n,
                              .y = predictors,
                              ~2*sqrt((.y+1)/.x)),
         dfbetas = map(.x = lm_object,
                       ~dfbetas(.x)),
         dfbetas_cutoff = map(.x = n,
                              ~2/sqrt(.x))
  )

#testing the principle of filtering by taxa within a function
taxa_filter <- function(preservation_method_data, taxon){
  taxon <- rlang::parse_expr(taxon)
  dplyr::filter(preservation_method_data, !!taxon)
}

taxa_filter(biomass_frozen_percentiles, "taxa_clean == 'Amphipoda'")

#Trying to filter taxa within the function
leverage <- function(preservation_method_data, taxon, mass_measure_1, mass_measure_2){
  taxon <- rlang::parse_expr(taxon)
  data <- dplyr::filter(preservation_method_data, !!taxon)
  lm_object <- lm({{mass_measure_2}} ~ {{mass_measure_1}}, data = data)
  leverage_values <- hatvalues(lm_object)
  predictors <- length(coef(lm_object))-1
  n <- nrow(lm_object$model)
  leverage_cutoff <- 2*(predictors+1)/n
  ifelse(leverage_values < leverage_cutoff, TRUE, FALSE)
  }

leverage(biomass_frozen_percentiles, "taxa_clean == 'Amphipoda'", wm_g, dm_g)

# not worrying about taxa
leverage <- function(preservation_method_data, mass_measure_1, mass_measure_2){
  lm_object <- lm({{mass_measure_2}} ~ {{mass_measure_1}}, data = preservation_method_data)
  leverage_values <- hatvalues(lm_object)
  predictors <- length(coef(lm_object))-1
  n <- nrow(lm_object$model)
  leverage_cutoff <- 2*(predictors+1)/n
  ifelse(leverage_values < leverage_cutoff, TRUE, FALSE)
}

leverage(biomass_frozen_percentiles, wm_g, dm_g)
```

Creating logical vectors identifying which observations fall outside the cutoff value or range for each measure of outlyingness
```{r}

taxa_nested_outliers_identified <- taxa_nested_outlier_measures |>
  mutate(keep_data_leverage = map2(.x = leverage,
                         .y = leverage_cutoff,
                         ~.x < .y),
         keep_data_stud_resid = map2(.x = stud_residual,
                                     .y = critical_t,
                                     ~.x < .y & .x > -.y),
         keep_data_cook = map2(.x = cooks_d,
                          .y = cooks_d_cutoff,
                          ~.x < .y),
         keep_data_dffits = map2(.x = dffits,
                                 .y = dffits_cutoff,
                                 ~.x < .y & .x > -.y),
         keep_data_dfbetas = map2(.x = dfbetas,
                                  .y = dfbetas_cutoff,
                                  ~.x < .y & .x > -.y))

```

Checking which observations of a particular taxa are identified by different measures of outlyingess
```{r}

taxa_nested_outliers_identified |>
  unnest(cols = c(data, leverage,
  stud_residual, cooks_d, dffits,
  dfbetas, keep_data_leverage, keep_data_stud_resid,
  keep_data_cook, keep_data_dffits, keep_data_dfbetas)) |>
  filter(taxa_clean == "Amphipoda") |>
  select(leverage, keep_data_leverage, obs_num) |>
  arrange(desc(leverage))|> print(n = Inf) |>
  tabyl(keep_data_leverage)

```

Unnesting the data and consolidating all outlier candidates into one vector
```{r}

taxa_unnested <- taxa_nested_outliers_identified |>
  select(taxa_clean, data, keep_data_leverage, keep_data_stud_resid, keep_data_cook, keep_data_dffits, keep_data_dfbetas) |> 
  unnest(cols = c(taxa_clean, data, keep_data_leverage, keep_data_stud_resid, keep_data_cook, keep_data_dffits, keep_data_dfbetas)) 

taxa_unnested_keep_data_merged <- taxa_unnested |>
 # assigning dfbetas values for intercept and slope to separate vectors
   mutate(keep_data_dfbetas_int = keep_data_dfbetas[,1], 
         keep_data_dfbetas_slope = keep_data_dfbetas[,2]) |>
 # Consolidating all outlier candidates into one vector
   mutate(keep_data = ifelse(keep_data_wm_percentiles == TRUE & keep_data_dm_percentiles == TRUE & keep_data_cook == TRUE & keep_data_leverage == TRUE & keep_data_stud_resid == TRUE & keep_data_dffits == TRUE & keep_data_dfbetas_int == TRUE & keep_data_dfbetas_slope == TRUE, TRUE, FALSE)) 

```

### Getting a summary table of counts for all outlier methods 
```{r}

long_data <- taxa_unnested_keep_data_merged |> 
  ungroup() |> 
  select(-c(keep_data_dfbetas)) |> 
  pivot_longer(starts_with("keep"), names_to = "outlier_method") 

long_data |> 
  group_by(outlier_method) |> 
  summarise(n = n(),
            n_FALSE = length(which(value == FALSE)),
            n_TRUE = length(which(value == TRUE)),
            n_NA = length(which(is.na(value))),
            n_add_check = n_FALSE + n_TRUE + n_NA,
            percent_false_or_NA = (n_FALSE+n_NA)/(n_FALSE+n_TRUE+n_NA)*100
  )

```

# Save the data
```{r}
biomass_frozen_outliers_identified <- taxa_unnested_keep_data_merged |>
  select(taxa_clean, wm_g, dm_g, keep_data)

write_csv(biomass_frozen_outliers_identified, here("data/processed/biomass_frozen_outliers_identified.csv"))
```

