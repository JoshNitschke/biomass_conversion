---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(here)
library(smatr)
library(janitor)
library(skimr)
library(gridExtra)
library(olsrr)
```


```{r, warning=FALSE}
biomass_data_taxaclean <- read_csv(here("data/processed/biomass_data_cleannames.csv"))
```

## setting minimum mass cut-off (due to higher proportional measurement error at very small mass values)

```{r}
#biomass_data_taxaclean_mass_cutoff <- 
  
tabyl(biomass_data_taxaclean$taxa_clean)
biomass_data_taxaclean |>
    filter(wm_g >= 0.001, dm_g >=0.001, afdm_g >=0.001, wm_g >= dm_g, dm_g >= afdm_g) |>
  select(source, taxa_clean, preservation_method, wm_g, dm_g, afdm_g) |>
  print(n = Inf)
```

## filter frozen samples only

```{r}
biomass_frozen_taxaclean_mass_cutoff <- biomass_data_taxaclean_mass_cutoff |>
  filter(preservation_method == "Frozen")
```

## Create observation number

```{r}
biomass_wobs <- biomass_frozen_taxaclean_mass_cutoff |> 
  mutate(obs_num = row_number())
```

## Outliers

Obs: 5747, 3859

```{r}
# A Clevaland plot
ggplot(biomass_wobs, aes(x = dm_g, y = obs_num, label = obs_num)) +
  geom_point(colour = "white") +
  geom_text() + 
  theme_bw()         
```

## Percentiles (2.5 and 97.5)
```{r}

biomass_percentiles <- biomass_wobs |>  
  group_by(taxa_clean) |> 
  summarize("wm_2.5_percentile" = quantile(wm_g, 0.025, na.rm = TRUE),
            "wm_97.5_percentile" = quantile(wm_g, 0.975, na.rm = TRUE),
            "dm_2.5_percentile" = quantile(dm_g, 0.025, na.rm = TRUE),
            "dm_97.5_percentile" = quantile(dm_g, 0.975, na.rm = TRUE))
biomass_percentiles

biomass_frozen_percentiles_removed <- 
  biomass_wobs_z |>
 mutate(wm_g_trimmed = ifelse(wm_g >= quantile(wm_g, 0.025, na.rm = TRUE) & wm_g <= quantile(wm_g, 0.975, na.rm = TRUE), wm_g, NA),
        dm_g_trimmed = ifelse(dm_g >= quantile(dm_g, 0.025, na.rm = TRUE) & dm_g <= quantile(dm_g, 0.975, na.rm = TRUE), dm_g, NA))

# Checking for peace of mind
  biomass_wobs_z |>
 mutate(wm_g_trimmed = ifelse(wm_g >= quantile(wm_g, 0.025, na.rm = TRUE) & wm_g <= quantile(wm_g, 0.975, na.rm = TRUE), wm_g, NA),
        dm_g_trimmed = ifelse(dm_g >= quantile(dm_g, 0.025, na.rm = TRUE) & dm_g <= quantile(dm_g, 0.975, na.rm = TRUE), dm_g, NA),
        quantile_2_5_wm = quantile(wm_g, 0.025, na.rm = TRUE),
        quantile_97_5_wm = quantile(wm_g, 0.975, na.rm = TRUE),
        quantile_2_5_dm = quantile(dm_g, 0.025, na.rm = TRUE),
        quantile_97_5_dm = quantile(dm_g, 0.975, na.rm = TRUE)) |> 
  select(taxa_clean, wm_g_trimmed, dm_g_trimmed, starts_with("quantile")) |> 
    arrange(taxa_clean) |> 
    View()

#trying to check if trimming worked properly
biomass_frozen_percentiles_removed |>
  summarize(wm_g_min = min(wm_g, na.rm = TRUE),
            wm_g_max = max(wm_g, na.rm = TRUE),
            wm_g_trimmed_min = min(wm_g_trimmed, na.rm = TRUE),
            wm_g_trimmed_max = max(wm_g_trimmed, na.rm = TRUE))

# testing more efficient method of above
biomass_frozen_percentiles_removed |>
  summarize_at(vars("wm_g", "wm_g_trimmed"), funs(min = min(., na.rm = TRUE),
            max = max(., na.rm = TRUE)))

# still trying to check if trimming worked properly
biomass_frozen_percentiles_removed|>
  summarise(wm_g_trimmed_na = sum(is.na(wm_g_trimmed)),
            wm_g_trimmed_na_pct = sum(is.na(wm_g_trimmed))/n(),
            dm_g_trimmed_na = sum(is.na(dm_g_trimmed)),
            dm_g_trimmed_na_pct = sum(is.na(dm_g_trimmed))/n()) |>
  print(n = 30)


# Which observations are removed by percentile method
biomass_frozen_percentiles_removed |> 
  ungroup() |> 
  filter(is.na(wm_g_trimmed)) |> 
  select(taxa_clean, wm_g, wm_g_trimmed, obs_num)
               
```

## Cooks Distance

Cook statistic in linear regression

```{r}
#OLS regression of dm~wm for Amphipoda
amphipoda_ols_data <- biomass_frozen_percentiles_removed |>
  filter(taxa_clean == "Amphipoda")

amphipoda_ols <- lm(dm_g~wm_g, data = amphipoda_ols_data)
summary(amphipoda_ols)

ggplot(amphipoda_ols, aes(x = dm_g, y= wm_g)) +
  geom_point(alpha = 0.50) + stat_smooth(method = "lm")

#cook's distance based on the OLS regression
cooks.distance(amphipoda_ols)

#filtering outliers based on threshold value of cook's D, i.e. critical value from F distribution, as per Aguinis et al. (2013)  
biomass_frozen_outliers_amphipoda <- biomass_frozen_percentiles_removed |>
  filter(taxa_clean == "Amphipoda") |>
  mutate(cooks_d = cooks.distance(amphipoda_ols)) |>
  filter(cooks_d >= qf(0.5, 2, 224, lower.tail = FALSE))
biomass_frozen_outliers_amphipoda |>
  select(wm_g, dm_g, cooks_d)

biomass_frozen_outliers_removed_amphipoda <- biomass_frozen_percentiles_removed |>
  filter(taxa_clean == "Amphipoda") |>
  mutate(cooks_d = cooks.distance(amphipoda_ols)) |>
  filter(cooks_d < qf(0.5, 2, 224, lower.tail = FALSE))

# amphipoda_ols$df.residual == 224

biomass_frozen_outliers_removed_amphipoda |>
  select(wm_g, dm_g, cooks_d) |>
  arrange(desc(cooks_d))

#plot of cook's D
ols_plot_cooksd_bar(amphipoda_ols)

# Get 'our' observation number
biomass_frozen_percentiles_removed |>
  filter(taxa_clean == "Amphipoda") |>
  mutate(cooks_d = cooks.distance(amphipoda_ols)) |>
  filter(cooks_d > qf(0.5, 2, 224, lower.tail = FALSE)) |> 
  select(taxa_clean, cooks_d, obs_num)
```

## Iterating over different taxa for Cook's Distance

```{r}
#install.packages(c("purrr", "tidyr"))
library(purrr)
library(tidyr)


# Classic approach, splitting data into seperate lists
classic_list_by_taxa <- split(biomass_frozen_percentiles_removed, biomass_frozen_percentiles_removed$taxa_clean)

# or we can repeat ourselves
biomass_frozen_percentiles_removed |> 
  select(taxa_clean, wm_g, dm_g) |> 
  filter(taxa_clean == "Simplisetia")

# Tidier version is using nest
taxa_nested <- biomass_frozen_percentiles_removed |> 
  select(taxa_clean, wm_g, dm_g) |> 
  nest(data = c(wm_g, dm_g)) |> 
  print(n = 30)

# ways of accessing nested data
taxa_nested |> pluck("data", 1)
simplisetia <- taxa_nested |> filter(taxa_clean == "Simplisetia") 
simplisetia$data
```

### Introducing map() 

```{r}
taxa_lm <- taxa_nested |> 
  mutate(lm_object = map(.x = data, # The input we want to iterate/ repeat processes on
                         ~ lm(dm_g ~ wm_g, data = .x)) # The thing/action we need to do on each chunk)
  )

# Take a look
taxa_lm |> pluck("lm_object", 1)
```

Here we are generating [descriptive stats] for outlier detection and subseq

```{r}
taxa_lm |> 
  mutate(cooks_d = map(.x = lm_object,
    ~ cooks.distance(.x)))
  
# Chaining your maps
taxa_cook <- taxa_nested |> 
  mutate(lm_object = map(.x = data, # The input we want to iterate/ repeat processes on
                         ~ lm(dm_g ~ wm_g, data = .x)), # The thing/action we need to do on each chunk)
         cooks_d = map(.x = lm_object, 
                       ~ cooks.distance(.x)),
         df_residual = map(.x = lm_object, 
                       ~ .x$df.residual),
         leverage = map(.x = lm_object,
                        ~ hatvalues(.x)),
         n = map(.x = lm_object,
                 ~ nrow(.x$model)),
         predictors = map(.x = lm_object,
                          ~length(coef(.x))-1),
         alpha_tdist = map(.x = n,
                           ~0.05/.x),
         df_tdist = map2(.x = n,
                         .y = predictors,
                         ~.x-.y-1),
         critical_t = map2(.x = alpha_tdist,
                           .y = df_tdist,
                           ~qt(.x/2, .y, lower.tail = FALSE, log.p = FALSE)),
         stud_residual = map(.x = lm_object,
                             ~rstudent(.x)),
         dffits = map(.x = lm_object,
                      ~dffits(.x)),
         dffits_cutoff = map2(.x = n,
                              .y = predictors,
                              ~2*sqrt((.y+1)/.x)),
         dfbetas = map(.x = lm_object,
                       ~dfbetas(.x)),
         dfbetas_cutoff = map(.x = n,
                              ~2/sqrt(.x))
  )

taxa_cook$dfbetas_cutoff

# (length(coef(lm_object))-1)      formula for no. of predictors 
```

## Introducing map2

```{r}
taxa_lgl <- taxa_cook |> mutate(leverage_cutoff = map2(.x = lm_object,
                                                      .y = n,
                                                      ~ 2*((length(coef(.x))-1)+1)/.y)) |>
  mutate(keep_data_cook = map2(.x = cooks_d,
                          .y = df_residual,
                          ~.x < qf(0.5, 2, .y, lower.tail = FALSE))) |>
  mutate(keep_data_leverage = map2(.x = leverage,
                         .y = leverage_cutoff,
                         ~.x < .y)) |>
  mutate(keep_data_stud_resid = map2(.x = stud_residual,
                                     .y = critical_t,
                                     ~.x < .y & .x > -.y)) |>
  mutate(keep_data_dffits = map2(.x = dffits,
                                 .y = dffits_cutoff,
                                 ~.x < .y & .x > -.y)) |>
  mutate(keep_data_dfbetas = map2(.x = dfbetas,
                                  .y = dfbetas_cutoff,
                                  ~.x < .y & .x > -.y))


#Why does this return all zero's?
# taxa_lgl <- taxa_cook |> mutate(leverage_cutoff = map(.x = n,
#                                                      ~ 2*((length(coef(lm_object))-1)+1)/.x))
#taxa_lgl$leverage_cutoff
#but this works?
# taxa_lgl <- taxa_cook |> mutate(leverage_cutoff = map2(.x = lm_object,
#                                                       .y = n,
#                                                       ~ 2*((length(coef(.x))-1)+1)/.y))
# taxa_lgl$stud_residual


#Checking leverage value cutoff for Amphipoda
2*((length(coef(amphipoda_ols))-1)+1)/226

taxa_lgl |>
  select(leverage, stud_residual, cooks_d, dffits, dfbetas, keep_data_cook, keep_data_leverage, keep_data_stud_resid, keep_data_dffits, keep_data_dfbetas, taxa_clean)|>
  unnest(cols = c(leverage, stud_residual, cooks_d, dffits, dfbetas, keep_data_cook, keep_data_leverage, keep_data_stud_resid, keep_data_dffits, keep_data_dfbetas, taxa_clean)) |>
  filter(taxa_clean == "Amphipoda") |>
  select(dfbetas, keep_data_dfbetas) |>
  arrange(desc(dfbetas))|> print(n = Inf) |>
  tabyl(keep_data_dfbetas)
```


## Unnesting time

```{r}
# Check your rows pre and post nest
taxa_lgl |>
  select(data, keep_data_cook, keep_data_leverage, keep_data_stud_resid, keep_data_dffits, keep_data_dfbetas) |> 
  unnest(cols = c(data, keep_data_cook, keep_data_leverage, keep_data_stud_resid, keep_data_dffits, keep_data_dfbetas)) |> 
  nrow()

nrow(biomass_frozen_percentiles_removed)

taxa_unnested <- taxa_lgl |>
  select(data, keep_data_cook, keep_data_leverage, keep_data_stud_resid, keep_data_dffits, keep_data_dfbetas) |> 
  unnest(cols = c(data, keep_data_cook, keep_data_leverage, keep_data_stud_resid, keep_data_dffits, keep_data_dfbetas)) 

# checking separation of dfbetas values for intercept and slope
taxa_unnested$keep_data_dfbetas
keep_data_dfbetas_int <- taxa_unnested$keep_data_dfbetas[,1]
keep_data_dfbetas_slope <- taxa_unnested$keep_data_dfbetas[,2]
keep_data_dfbetas_int == keep_data_dfbetas_slope

# Filter out values based on thresholds of outlier measures
taxa_unnested <- taxa_unnested |>
  mutate(keep_data_dfbetas_int = keep_data_dfbetas[,1], 
         keep_data_dfbetas_slope = keep_data_dfbetas[,2]) |>
  mutate(keep_data_wm_percentiles = ifelse(wm_g >= quantile(wm_g, 0.025, na.rm = TRUE) & wm_g <= quantile(wm_g, 0.975, na.rm = TRUE), TRUE, FALSE),
        keep_data_dm_percentiles = ifelse(dm_g >= quantile(dm_g, 0.025, na.rm = TRUE) & dm_g <= quantile(dm_g, 0.975, na.rm = TRUE), TRUE, FALSE)) |>
  mutate(keep_data = ifelse(keep_data_wm_percentiles == TRUE & keep_data_dm_percentiles == TRUE & keep_data_cook == TRUE & keep_data_leverage == TRUE & keep_data_stud_resid == TRUE & keep_data_dffits == TRUE & keep_data_dfbetas_int == TRUE & keep_data_dfbetas_slope == TRUE, TRUE, FALSE)) 

taxa_unnested |> 
  pull(keep_data) |> 
  janitor::tabyl()

biomass_frozen_outliers_removed <- taxa_unnested |> 
  filter(keep_data == TRUE) |>
  select(taxa_clean, wm_g, dm_g)

biomass_frozen_outliers_removed


### A possible alternative but not as good as yours! because u can't check the remaining FALSEs
taxa_unnested |> 
  mutate(keep_data_dfbetas_int = keep_data_dfbetas[,1], 
         keep_data_dfbetas_slope = keep_data_dfbetas[,2]) |>
  mutate(keep_data_wm_percentiles = ifelse(wm_g >= quantile(wm_g, 0.025, na.rm = TRUE) & wm_g <= quantile(wm_g, 0.975, na.rm = TRUE), TRUE, FALSE),
         keep_data_dm_percentiles = ifelse(dm_g >= quantile(dm_g, 0.025, na.rm = TRUE) & dm_g <= quantile(dm_g, 0.975, na.rm = TRUE), TRUE, FALSE)) |>
  filter(keep_data_wm_percentiles == TRUE & keep_data_dm_percentiles == TRUE & keep_data_cook == TRUE & keep_data_leverage == TRUE & keep_data_stud_resid == TRUE & keep_data_dffits == TRUE & keep_data_dfbetas_int == TRUE & keep_data_dfbetas_slope == TRUE) 
```

### Get a summary table of counts for all outlier methods 
```{r}
# Get n for each taxa
taxa_lgl |>
  select(n) |> 
  unnest() |> 
  print(n = Inf)

# The NAs are ok!
taxa_unnested |> 
  ungroup() |> 
  filter(is.na(keep_data_cook))
  #colSums(na.rm = )

# Hacky
taxa_unnested |> 
  ungroup() |> 
  select(starts_with("keep")) |> 
  colSums(na.rm = TRUE) # Sums all the TRUES in each column

# Wrangling way
long_data <- taxa_unnested |> 
  ungroup() |> 
  select(-c(keep_data_dfbetas)) |> 
  pivot_longer(starts_with("keep"), names_to = "outlier_method") 

# Summary of counts
long_data |> 
  group_by(outlier_method) |> 
  summarise(n = n(),
            n_FALSE = length(which(value == FALSE)),
            n_TRUE = length(which(value == TRUE)),
            n_NA = length(which(is.na(value))),
            n_add_check = n_FALSE + n_TRUE + n_NA
  )

# Treating as numeric TRUE becomes 1 FALSE becomes 0
# Then we spcify condition == 0 means identifying the false ones
# Wrapping which around the identified values, tells us the index/observation number of the ones we've identified
long_data$value
as.numeric(long_data$value)
as.numeric(long_data$value) == 0

which(as.numeric(long_data$value) == 0)

length(long_data$value)

length(which(as.numeric(long_data$value) == 0))
```


# Save the cleaned data

```{r}
write_csv(biomass_frozen_outliers_removed, here("data/processed/biomass_conversions_frozen_nooutliers.csv"))
```

